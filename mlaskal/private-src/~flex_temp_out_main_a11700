m4_changequote
m4_changequote([[, ]])
m4_define( [[M4_YY_NO_UNPUT]], [[]])m4_dnl
m4_define( [[M4_YY_STACK_USED]], [[]])m4_dnl
m4_define( [[M4_YY_NEVER_INTERACTIVE]], [[]])m4_dnl
m4_define( [[M4_YY_TABLES_VERIFY]], [[0]])m4_dnl
m4_define( [[M4_YY_REENTRANT]], [[]])m4_dnl
m4_define( [[M4_YY_PREFIX]], [[yy]])m4_dnl
m4_define( [[M4_YY_SC_DEFS]], [[#define INITIAL 0
]])m4_dnl
#line 0 "M4_YY_OUTFILE_NAME"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */



m4_changecom
m4_changequote
m4_changequote([[, ]])


m4_ifdef( [[M4_YY_IN_HEADER]],,[[
]])

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 37
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

m4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])
m4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])

m4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])
m4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])



m4_ifdef( [[M4_YY_PREFIX]],, [[m4_define([[M4_YY_PREFIX]], [[yy]])]])




    m4_define(yy[[_create_buffer]], [[M4_YY_PREFIX[[_create_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_delete_buffer]], [[M4_YY_PREFIX[[_delete_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_scan_buffer]], [[M4_YY_PREFIX[[_scan_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_scan_string]], [[M4_YY_PREFIX[[_scan_string]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_scan_bytes]], [[M4_YY_PREFIX[[_scan_bytes]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_init_buffer]], [[M4_YY_PREFIX[[_init_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_flush_buffer]], [[M4_YY_PREFIX[[_flush_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_load_buffer_state]], [[M4_YY_PREFIX[[_load_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_switch_to_buffer]], [[M4_YY_PREFIX[[_switch_to_buffer]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[push_buffer_state]], [[M4_YY_PREFIX[[push_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[pop_buffer_state]], [[M4_YY_PREFIX[[pop_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[ensure_buffer_stack]], [[M4_YY_PREFIX[[ensure_buffer_stack]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[lex]], [[M4_YY_PREFIX[[lex]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[restart]], [[M4_YY_PREFIX[[restart]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[lex_init]], [[M4_YY_PREFIX[[lex_init]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[lex_init_extra]], [[M4_YY_PREFIX[[lex_init_extra]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[lex_destroy]], [[M4_YY_PREFIX[[lex_destroy]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[get_debug]], [[M4_YY_PREFIX[[get_debug]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[set_debug]], [[M4_YY_PREFIX[[set_debug]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[get_extra]], [[M4_YY_PREFIX[[get_extra]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[set_extra]], [[M4_YY_PREFIX[[set_extra]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[get_in]], [[M4_YY_PREFIX[[get_in]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[set_in]], [[M4_YY_PREFIX[[set_in]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[get_out]], [[M4_YY_PREFIX[[get_out]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[set_out]], [[M4_YY_PREFIX[[set_out]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[get_leng]], [[M4_YY_PREFIX[[get_leng]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[get_text]], [[M4_YY_PREFIX[[get_text]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[get_lineno]], [[M4_YY_PREFIX[[get_lineno]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[set_lineno]], [[M4_YY_PREFIX[[set_lineno]]m4_ifelse($#,0,,[[($@)]])]])
    m4_ifdef( [[M4_YY_REENTRANT]],
    [[
        m4_define(yy[[get_column]], [[M4_YY_PREFIX[[get_column]]m4_ifelse($#,0,,[[($@)]])]])
        m4_define(yy[[set_column]], [[M4_YY_PREFIX[[set_column]]m4_ifelse($#,0,,[[($@)]])]])
    ]])
    m4_define(yy[[wrap]], [[M4_YY_PREFIX[[wrap]]m4_ifelse($#,0,,[[($@)]])]])

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    m4_define(yy[[get_lval]], [[M4_YY_PREFIX[[get_lval]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[set_lval]], [[M4_YY_PREFIX[[set_lval]]m4_ifelse($#,0,,[[($@)]])]])
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    m4_define(yy[[get_lloc]], [[M4_YY_PREFIX[[get_lloc]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[set_lloc]], [[M4_YY_PREFIX[[set_lloc]]m4_ifelse($#,0,,[[($@)]])]])
]])


    m4_define(yy[[alloc]], [[M4_YY_PREFIX[[alloc]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[realloc]], [[M4_YY_PREFIX[[realloc]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[free]], [[M4_YY_PREFIX[[free]]m4_ifelse($#,0,,[[($@)]])]])

m4_ifdef( [[M4_YY_NOT_REENTRANT]],
[[
    m4_define(yy[[text]], [[M4_YY_PREFIX[[text]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[leng]], [[M4_YY_PREFIX[[leng]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[in]], [[M4_YY_PREFIX[[in]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[out]], [[M4_YY_PREFIX[[out]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[_flex_debug]], [[M4_YY_PREFIX[[_flex_debug]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[lineno]], [[M4_YY_PREFIX[[lineno]]m4_ifelse($#,0,,[[($@)]])]])
]])


m4_ifdef( [[M4_YY_TABLES_EXTERNAL]],
[[
    m4_define(yy[[tables_fload]], [[M4_YY_PREFIX[[tables_fload]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[tables_destroy]], [[M4_YY_PREFIX[[tables_destroy]]m4_ifelse($#,0,,[[($@)]])]])
    m4_define(yy[[TABLES_NAME]], [[M4_YY_PREFIX[[TABLES_NAME]]m4_ifelse($#,0,,[[($@)]])]])
]])

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */



#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif	/* defined (__STDC__) */
#endif	/* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

m4_ifdef( [[M4_YY_NO_ANSI_FUNC_PROTOS]],
[[
    m4_define( [[M4_YY_PARAMS]], [[()]])
]],
[[
    m4_define( [[M4_YY_PARAMS]], [[($*)]])
]])

m4_ifdef( [[M4_YY_IN_HEADER]],,[[
/* Returned upon end-of-file. */
#define YY_NULL 0
]])

m4_ifdef( [[M4_YY_IN_HEADER]],,[[
/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
]])




/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

m4_define( [[M4_YY_DECL_GUTS_VAR]], [[struct yyguts_t * yyg = (struct yyguts_t*)yyscanner]])
m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[(void)yyg]])
m4_define( [[YY_G]], [[yyg->$1]])

m4_define( [[M4_YY_PROTO_LAST_ARG]],  [[, yyscan_t yyscanner]])
m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[yyscan_t yyscanner]])

m4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],
[[
    m4_define( [[M4_YY_DEF_LAST_ARG]], [[, yyscanner]])
    m4_define( [[M4_YY_DEF_ONLY_ARG]], [[yyscanner]])
]],
[[
    m4_define( [[M4_YY_DEF_LAST_ARG]],  [[, yyscan_t yyscanner]])
    m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[yyscan_t yyscanner]])
]])
m4_define( [[M4_YY_DECL_LAST_ARG]],  [[yyscan_t yyscanner;]])

m4_define( [[M4_YY_CALL_LAST_ARG]], [[, yyscanner]])
m4_define( [[M4_YY_CALL_ONLY_ARG]], [[yyscanner]])

m4_define( [[M4_YY_DOC_PARAM]], [[@param yyscanner The scanner object.]])

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin YY_G(yyin_r)
#define yyout YY_G(yyout_r)
#define yyextra YY_G(yyextra_r)
#define yyleng YY_G(yyleng_r)
#define yytext YY_G(yytext_r)
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug YY_G(yy_flex_debug_r)

m4_define( [[M4_YY_INCR_LINENO]],
[[   
    do{ yylineno++;
        yycolumn=0;
    }while(0)
]])






m4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],
[[
    m4_define( [[YYFARGS0]], [[(M4_YY_DEF_ONLY_ARG) [[\]]
        M4_YY_DECL_LAST_ARG]])
    m4_define( [[YYFARGS1]], [[($2 M4_YY_DEF_LAST_ARG) [[\]]
        $1 $2; [[\]]
        M4_YY_DECL_LAST_ARG]])
    m4_define( [[YYFARGS2]], [[($2,$4 M4_YY_DEF_LAST_ARG) [[\]]
        $1 $2; [[\]]
        $3 $4; [[\]]
        M4_YY_DECL_LAST_ARG]])
    m4_define( [[YYFARGS3]], [[($2,$4,$6 M4_YY_DEF_LAST_ARG) [[\]]
        $1 $2; [[\]]
        $3 $4; [[\]]
        $5 $6; [[\]]
        M4_YY_DECL_LAST_ARG]])
]],
[[
    m4_define( [[YYFARGS0]], [[(M4_YY_DEF_ONLY_ARG)]])
    m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])
    m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])
    m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN YY_G(yy_start) = 1 + 2 *
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((YY_G(yy_start) - 1) / 2)
#define YYSTATE YY_START
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin M4_YY_CALL_LAST_ARG )
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define YY_END_OF_BUFFER_CHAR 0
]])

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
]])


#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif



m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
    m4_ifdef( [[M4_YY_USE_LINENO]],
    [[
    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
     *       access to the local variable yy_act. Since yyless() is a macro, it would break
     *       existing scanners that call yyless() from OUTSIDE yylex. 
     *       One obvious solution it to make yy_act a global. I tried that, and saw
     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
     *       normally declared as a register variable-- so it is not worth it.
     */
    #define  YY_LESS_LINENO(n) \
            do { \
                int yyl;\
                for ( yyl = n; yyl < yyleng; ++yyl )\
                    if ( yytext[yyl] == '\n' )\
                        --yylineno;\
            }while(0)
    ]],
    [[
    #define YY_LESS_LINENO(n)
    ]])
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = YY_G(yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		YY_G(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define unput(c) yyunput( c, YY_G(yytext_ptr) M4_YY_CALL_LAST_ARG )
]])

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;



	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	yy_size_t yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */
    

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
]])
	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

m4_ifdef( [[M4_YY_IN_HEADER]],,[[
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( YY_G(yy_buffer_stack) \
                          ? YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)] \
                          : NULL)
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)]
]])


m4_ifdef( [[M4_YY_IN_HEADER]],,[[
]])

void yyrestart M4_YY_PARAMS( FILE *input_file M4_YY_PROTO_LAST_ARG );
void yy_switch_to_buffer M4_YY_PARAMS( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );
YY_BUFFER_STATE yy_create_buffer M4_YY